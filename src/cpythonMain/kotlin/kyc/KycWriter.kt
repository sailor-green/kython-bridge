/*
 * This file is part of kython-bridge.
 *
 * kython-bridge is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * kython-bridge is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with kython.  If not, see <https://www.gnu.org/licenses/>.
 */


@file:Suppress("unused", "MemberVisibilityCanBePrivate")

package kyc

import PyBytes_AsByteArray
import PyBytes_Check
import PyCode_Check
import PyDict_Check
import PyError
import PyFloat_Check
import PyList_Check
import PyLong_Check
import PySet_Check
import PyTuple_Check
import PyUnicode_AsByteArray
import PyUnicode_Check
import cpython.*
import kotlinx.cinterop.pointed
import kotlinx.cinterop.ptr
import kotlinx.cinterop.reinterpret
import kotlinx.cinterop.toKString
import okio.Buffer
import okio.ByteString

fun Buffer.write(type: KycWriter.KycType) {
    type.write(this)
}

/**
 * Class for writing a code object to a buffer.
 */
class KycWriter {
    enum class KycType(val c: Char) {
        // simple objects
        NONE('N'),
        FALSE('-'),
        TRUE('+'),

        // numbers
        INT('i'),
        LONG('L'),
        FLOAT('f'),
        COMPLEX('y'),

        // byte types
        BYTESTRING('b'),

        // unicode types
        UNICODE_STRING('s'),

        // containers
        TUPLE('t'),
        LIST('l'),
        DICT('d'),
        SET('{'),
        FROZENSET('>'),

        // CodeType
        CODE('c'),

        // root type
        KY_FILE('K');

        /**
         * Writes a kyc type to a buffer.
         */
        fun write(buf: Buffer) {
            buf.writeUtf8(this.c.toString())
        }
    }

    companion object {
        const val KY_COMMENT = "This file was automatically generated by Kython. Do not edit!"

        /**
         * Compiles code to bytecode and writes it to
         */
        fun write(code: String, filename: String): ByteString {
            Py_NoSiteFlag = 1
            Py_IsolatedFlag = 1
            Py_DontWriteBytecodeFlag = 1
            Py_IgnoreEnvironmentFlag = 1
            Py_NoUserSiteDirectory = 1

            Py_InitializeEx(0)
            try {
                val compiled = Py_CompileStringExFlags(
                    code, filename, Py_file_input, null, 0
                ) ?: PyError("Failed to compile!")

                val pycode = compiled.reinterpret<PyCodeObject>().pointed
                val writer = KycWriter()

                // KYC magic number
                // Version 'A'
                writer.buffer.writeUtf8("KYCA")

                // Python version
                writer.buffer.writeByte(PY_MINOR_VERSION)


                // KYC file type marker
                writer.buffer.write(KycType.KY_FILE)

                // File hash
                writer.writeLong(0L)

                // File comment
                writer.writeString(KY_COMMENT.encodeToByteArray())

                // Code
                writer.writeCode(pycode)
                // make sure this gets GC'd
                // TODO: Somebody more experienced than me should check to see if this memleaks
                compiled.pointed.ob_refcnt = 0
                return writer.read()
            } finally {
                // clean up anything the interpreter has done
                Py_FinalizeEx()
            }

        }
    }

    private val buffer = Buffer()

    /**
     * Writes an int to the buffer.
     */
    private fun writeInt(i: Int) {
        buffer.write(KycType.INT)
        buffer.writeIntLe(i)
    }

    /**
     * Writes a long.
     */
    private fun writeLong(i: Long) {
        buffer.write(KycType.LONG)
        buffer.writeLongLe(i)
    }

    /**
     * Writes bytes.
     */
    private fun writeBytes(ba: ByteArray) {
        buffer.write(KycType.BYTESTRING)
        buffer.writeIntLe(ba.size)
        buffer.write(ba)
    }

    /**
     * Writes a tuple to the stream. Check with PyTuple_Check first.
     */
    private fun writeTuple(obb: PyObject) {
        val size = PyTuple_Size(obb.ptr)
        buffer.write(KycType.TUPLE)
        buffer.writeIntLe(size.toInt())

        for (idx in 0 until size) {
            val item = PyTuple_GetItem(obb.ptr, idx)
                ?: PyError("Somehow, index $idx out of range?")
            writeObject(item.pointed)
            // DO NOT DECREF
        }
    }

    /**
     * Writes a list to the stream. Check with PyList_Check first.
     */
    private fun writeList(obb: PyObject) {
        val size = PyList_Size(obb.ptr)
        buffer.write(KycType.LIST)
        buffer.writeIntLe(size.toInt())

        for (idx in 0 until size) {
            val item = PyList_GetItem(obb.ptr, idx)
                ?: PyError("Somehow, index $idx out of range?")
            writeObject(item.pointed)
            // DO NOT DECREF
        }
    }

    /**
     * Writes a string.
     */
    private fun writeString(ba: ByteArray) {
        buffer.write(KycType.UNICODE_STRING)
        buffer.writeIntLe(ba.size)
        buffer.write(ba)
    }

    /**
     * Writes a set.
     */
    private fun writeSet(obb: PyObject) {
        val ptr = obb.ptr
        val iter = PyObject_GetIter(ptr)
            ?: PyError("Failed to get set iterator?")

        buffer.write(KycType.SET)
        buffer.writeIntLe(PySet_Size(ptr).toInt())

        try {
            while (true) {
                val item = PyIter_Next(iter) ?: break
                // new ref, must decref
                Py_DecRef(item)
                writeObject(item.pointed)
            }
        } finally {
            Py_DecRef(iter)
        }

    }

    /**
     * Writes a dict.
     */
    private fun writeDict(obb: PyObject) {
        val ptr = obb.ptr
        val iter = PyObject_GetIter(ptr)
            ?: PyError("Failed to get set iterator?")

        buffer.write(KycType.DICT)
        buffer.writeLongLe(PyDict_Size(ptr))

        try {
            while (true) {
                val key = PyIter_Next(iter) ?: break
                writeObject(key.pointed)
                val item = PyDict_GetItem(ptr, key)!!
                writeObject(item.pointed)

                // key is new reference, must decref
                Py_DecRef(key)
            }
        } finally {
            Py_DecRef(iter)
        }

    }

    /**
     * Writes floats.
     */
    private fun writeFloat(obb: PyObject) {
        val dub = PyFloat_AsDouble(obb.ptr)
        val bits = dub.toBits()

        buffer.write(KycType.FLOAT)
        buffer.writeLongLe(bits)
    }

    /**
     * Writes an object to the stream.
     */
    private fun writeObject(obb: PyObject) {
        // bools come first as they are ints
        // so this stops them being compiled to kyc ints
        when {
            obb == Py_True!!.pointed -> buffer.write(KycType.TRUE)
            obb == Py_False!!.pointed -> buffer.write(KycType.FALSE)
            PyCode_Check(obb) -> writeCode(obb.reinterpret())
            PyLong_Check(obb) -> writeLong(PyLong_AsLong(obb.ptr))
            PyFloat_Check(obb) -> writeFloat(obb)
            PyList_Check(obb) -> writeList(obb)
            PyBytes_Check(obb) -> writeBytes(PyBytes_AsByteArray(obb))
            PyUnicode_Check(obb) -> writeString(PyUnicode_AsByteArray(obb))
            PyTuple_Check(obb) -> writeTuple(obb)
            PySet_Check(obb) -> writeSet(obb)
            PyDict_Check(obb) -> writeDict(obb)
            obb == Py_None!!.pointed -> buffer.write(KycType.NONE)
            else -> error("Unknown object ${obb.ob_type!!.pointed.tp_name!!.toKString()}")
        }
    }

    /**
     * Writes a code object to the stream.
     */
    private fun writeCode(code: PyCodeObject) {
        // initial code
        buffer.write(KycType.CODE)

        // int fields
        writeInt(code.co_argcount)
        writeInt(code.co_posonlyargcount)
        writeInt(code.co_kwonlyargcount)
        writeInt(code.co_nlocals)
        writeInt(code.co_stacksize)
        writeInt(code.co_flags)

        // co_code should always be bytes
        if (!PyBytes_Check(code.co_code!!.pointed)) {
            error("co_code isn't bytes!")
        }

        writeBytes(PyBytes_AsByteArray(code.co_code!!.pointed))
        writeTuple(code.co_consts!!.pointed)
        writeTuple(code.co_names!!.pointed)
        writeTuple(code.co_varnames!!.pointed)
        writeTuple(code.co_freevars!!.pointed)
        writeTuple(code.co_cellvars!!.pointed)

        writeString(PyUnicode_AsByteArray(code.co_filename!!.pointed))
        writeString(PyUnicode_AsByteArray(code.co_name!!.pointed))
        writeInt(code.co_firstlineno)
        writeBytes(PyBytes_AsByteArray(code.co_lnotab!!.pointed))
    }


    /**
     * Reads the underlying ByteArray.
     */
    fun read(): ByteString {
        return buffer.readByteString()
    }
}

